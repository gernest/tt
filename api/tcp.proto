syntax = "proto3";

option go_package = "girhub.com/gernest/tt/api";

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";

service Proxy { rpc Configure(Config) returns (Response); }

message Response {
  oneof result {
    bool ok = 1;
    string error = 2;
  }
}

message Config { repeated Route routes = 1; }

message WeightedAddr {
  Address addr = 1;
  uint32 weight = 3;
  map<string, string> metric_labels = 4;
}

message Address {
  string network = 1;
  string address = 2;
}

message Route {
  enum LoadBalanceAlgo {
    RoundRobinWeighted = 0;
    RandomWeighted = 1;
    SmoothWeighted = 2;
  }
  Address src = 1;
  RequestMatch condition = 2;
  map<string, string> metrics_labels = 3;
  Retries retries = 4;
  google.protobuf.Duration timeout = 5;
  google.protobuf.Duration keepAlive = 6;
  WeightedAddr endpoint = 7;
  repeated WeightedAddr load_balance = 8;
  LoadBalanceAlgo load_balance_algo = 9;
  bool allow_acme = 10;
  bool enable_optimized_copy = 11;
  Speed speed = 12;
}

// Speed defines rate limiting of how fast data willl be copied. This is a
// described in bytes units
// "B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"
//
// I you want do have upload speed of up to 40 mp per seconds then you can set
// downstream="20MiB/s"
message Speed {
  // The rate at which bytes are written to downstream connection. By downstream
  // connection we are refering to a connection established on tt server by the
  // world
  //   World => tt => Internal
  //   World [==> downstream connection] tt => Internal
  string downstream = 1;
  // The rate at which bytes are written to upstream connection. By upstream
  // connection we are refering to a connection established by tt server to the
  // configured internal service.
  //   World => tt => Internal
  //   World => tt [=> upstream connection] Internal
  string upstream = 2;
}

message Retries {
  bool enabled = 1;
  RetryBudget budget = 2;
}

message RetryBudget {
  // The ratio of additional traffic that may be added by retries.  A
  // retry_ratio of 0.1 means that 1 retry may be attempted for every 10 regular
  // requests.  A retry_ratio of 1.0 means that 1 retry may be attempted for
  // every 1 regular request (in other words, total request load may be doubled
  // as a result of retries).
  float retry_ratio = 1;
  // The proxy may always attempt this number of retries per second, even if it
  // would violate the retry_ratio.  This is to allow retries to happen even
  // when the request rate is very low.
  uint32 min_retries_per_second = 2;
  // This duration indicates for how long requests should be considered for the
  // purposes of enforcing the retry_ratio.  A higher value considers a larger
  // window and therefore allows burstier retries.
  google.protobuf.Duration ttl = 3;
}

message RequestMatch {
  oneof match {
    string sni = 1;
    string host = 2;
    string path = 3;
    google.protobuf.Empty fixed = 4;
  }
}

message Context {
  enum Protocol {
    TCP = 0;
    UDP = 1;
    HTTP = 2;
    WEBSOCKET = 3;
    QUIC = 4;
  }
  message Stat {
    int64 bytesRead = 1;
    int64 bytesWritten = 2;
  }
  message Conn {
    string localAddress = 1;
    string remoteAddress = 2;
    Stat stat = 3;
  }
  message Info {
    google.protobuf.StringValue sni = 1;
    google.protobuf.StringValue host = 2;
    google.protobuf.StringValue path = 3;
    string routeName = 4;
    int32 listenPort = 5;
  }
  int64 id = 1;
  Protocol protocol = 2;
  Conn downstream = 3;
  Conn upstream = 4;
  Info info = 5;
}

message Rule {
  message List { repeated Rule rules = 1; }

  oneof match {
    List all = 1;
    List any = 2;
    Rule not = 3;

    TCP tcp = 4;
    HTTP http = 5;
  }

  message TCP {
    oneof match {
      uint32 port = 1;
      PortRange ports = 2;
      string sni = 3;
    }

    message PortRange {
      uint32 min = 1;
      uint32 max = 2;
    }
  }

  message HTTP {
    oneof match {
      Methods methods = 1;
      StringMatch path = 2;
      string host = 3;
      Headers headers = 4;
    }
    message Methods { repeated Method methods = 1; }
    message Headers { repeated Header headers = 1; }
    enum Method {
      GET = 0;
      POST = 1;
      PUT = 2;
      DELETE = 3;
      PATCH = 4;
      OPTIONS = 5;
      CONNECT = 6;
      HEAD = 7;
      TRACE = 8;
      ALL = 9;
    }
  }
  message Header {
    string key = 1;
    StringMatch vallue = 2;
  }

  message StringMatch {
    oneof match {
      string exact = 1;
      string prefix = 2;
      string regexp = 3;
    }
  }
}